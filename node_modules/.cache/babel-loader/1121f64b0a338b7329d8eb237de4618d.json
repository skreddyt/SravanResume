{"ast":null,"code":"import ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport definePointAccessors from '../accessors/define-point-accessors';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\n\nvar Segment = function (Class) {\n  function Segment(anchor, controlIn, controlOut) {\n    Class.call(this);\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n\n  if (Class) Segment.__proto__ = Class;\n  Segment.prototype = Object.create(Class && Class.prototype);\n  Segment.prototype.constructor = Segment;\n\n  Segment.prototype.bboxTo = function bboxTo(toSegment, matrix) {\n    var segmentAnchor = this.anchor().transformCopy(matrix);\n    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    var rect;\n\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n\n    return rect;\n  };\n\n  Segment.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  };\n\n  Segment.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {\n    var points = [p1, cp1, cp2, p2];\n\n    var extremesX = this._curveExtremesFor(points, \"x\");\n\n    var extremesY = this._curveExtremesFor(points, \"y\");\n\n    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  };\n\n  Segment.prototype._curveExtremesFor = function _curveExtremesFor(points, field) {\n    var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  };\n\n  Segment.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {\n    var a = x1 - 3 * x2 + 3 * x3 - x4;\n    var b = -2 * (x1 - 2 * x2 + x3);\n    var c = x1 - x2;\n    var sqrt = Math.sqrt(b * b - 4 * a * c);\n    var t1 = 0;\n    var t2 = 1;\n\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n\n    var min = Math.max(Math.min(t1, t2), 0);\n\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n\n    var max = Math.min(Math.max(t1, t2), 1);\n\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  Segment.prototype._intersectionsTo = function _intersectionsTo(segment, point) {\n    var intersectionsCount;\n\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n\n    return intersectionsCount;\n  };\n\n  Segment.prototype._isOnCurveTo = function _isOnCurveTo(segment, point, width, endSegment) {\n    var bbox = this.bboxTo(segment).expand(width, width);\n\n    if (bbox.containsPoint(point)) {\n      var p1 = this.anchor();\n      var p2 = this.controlOut();\n      var p3 = segment.controlIn();\n      var p4 = segment.anchor();\n\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n      var points = [p1, p2, p3, p4];\n\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n\n      var rotation = transform().rotate(45, point);\n      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  };\n\n  Segment.prototype._isOnLineTo = function _isOnLineTo(segment, point, width) {\n    var p1 = this.anchor();\n    var p2 = segment.anchor();\n    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  };\n\n  Segment.prototype._isOnPathTo = function _isOnPathTo(segment, point, width, endSegment) {\n    var isOnPath;\n\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n\n    return isOnPath;\n  };\n\n  return Segment;\n}(Class);\n\ndefinePointAccessors(Segment.prototype, [\"anchor\", \"controlIn\", \"controlOut\"]);\nObserversMixin.extend(Segment.prototype);\n\nfunction arrayLimits(arr) {\n  var length = arr.length;\n  var min = MAX_NUM;\n  var max = MIN_NUM;\n\n  for (var i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nexport default Segment;","map":null,"metadata":{},"sourceType":"module"}