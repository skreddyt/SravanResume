{"ast":null,"code":"import ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport Point from './point';\nimport Size from './size';\n\nvar Rect = function (Class) {\n  function Rect(origin, size) {\n    if (origin === void 0) origin = new Point();\n    if (size === void 0) size = new Size();\n    Class.call(this);\n    this.setOrigin(origin);\n    this.setSize(size);\n  }\n\n  if (Class) Rect.__proto__ = Class;\n  Rect.prototype = Object.create(Class && Class.prototype);\n  Rect.prototype.constructor = Rect;\n\n  Rect.prototype.clone = function clone() {\n    return new Rect(this.origin.clone(), this.size.clone());\n  };\n\n  Rect.prototype.equals = function equals(other) {\n    return other && other.origin.equals(this.origin) && other.size.equals(this.size);\n  };\n\n  Rect.prototype.setOrigin = function setOrigin(value) {\n    this._observerField(\"origin\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Rect.prototype.getOrigin = function getOrigin() {\n    return this.origin;\n  };\n\n  Rect.prototype.setSize = function setSize(value) {\n    this._observerField(\"size\", Size.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Rect.prototype.getSize = function getSize() {\n    return this.size;\n  };\n\n  Rect.prototype.width = function width() {\n    return this.size.width;\n  };\n\n  Rect.prototype.height = function height() {\n    return this.size.height;\n  };\n\n  Rect.prototype.topLeft = function topLeft() {\n    return this.origin.clone();\n  };\n\n  Rect.prototype.bottomRight = function bottomRight() {\n    return this.origin.clone().translate(this.width(), this.height());\n  };\n\n  Rect.prototype.topRight = function topRight() {\n    return this.origin.clone().translate(this.width(), 0);\n  };\n\n  Rect.prototype.bottomLeft = function bottomLeft() {\n    return this.origin.clone().translate(0, this.height());\n  };\n\n  Rect.prototype.center = function center() {\n    return this.origin.clone().translate(this.width() / 2, this.height() / 2);\n  };\n\n  Rect.prototype.bbox = function bbox(matrix) {\n    var tl = this.topLeft().transformCopy(matrix);\n    var tr = this.topRight().transformCopy(matrix);\n    var br = this.bottomRight().transformCopy(matrix);\n    var bl = this.bottomLeft().transformCopy(matrix);\n    return Rect.fromPoints(tl, tr, br, bl);\n  };\n\n  Rect.prototype.transformCopy = function transformCopy(m) {\n    return Rect.fromPoints(this.topLeft().transform(m), this.bottomRight().transform(m));\n  };\n\n  Rect.prototype.expand = function expand(x, y) {\n    if (y === void 0) y = x;\n    this.size.width += 2 * x;\n    this.size.height += 2 * y;\n    this.origin.translate(-x, -y);\n    return this;\n  };\n\n  Rect.prototype.expandCopy = function expandCopy(x, y) {\n    return this.clone().expand(x, y);\n  };\n\n  Rect.prototype.containsPoint = function containsPoint(point) {\n    var origin = this.origin;\n    var bottomRight = this.bottomRight();\n    return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);\n  };\n\n  Rect.prototype._isOnPath = function _isOnPath(point, width) {\n    var rectOuter = this.expandCopy(width, width);\n    var rectInner = this.expandCopy(-width, -width);\n    return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);\n  };\n\n  Rect.fromPoints = function fromPoints() {\n    var topLeft = Point.min.apply(null, arguments);\n    var bottomRight = Point.max.apply(null, arguments);\n    var size = new Size(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n    return new Rect(topLeft, size);\n  };\n\n  Rect.union = function union(a, b) {\n    return Rect.fromPoints(Point.min(a.topLeft(), b.topLeft()), Point.max(a.bottomRight(), b.bottomRight()));\n  };\n\n  Rect.intersect = function intersect(a, b) {\n    var rect1 = {\n      left: a.topLeft().x,\n      top: a.topLeft().y,\n      right: a.bottomRight().x,\n      bottom: a.bottomRight().y\n    };\n    var rect2 = {\n      left: b.topLeft().x,\n      top: b.topLeft().y,\n      right: b.bottomRight().x,\n      bottom: b.bottomRight().y\n    };\n\n    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {\n      return Rect.fromPoints(new Point(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)), new Point(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)));\n    }\n  };\n\n  return Rect;\n}(Class);\n\nObserversMixin.extend(Rect.prototype);\nexport default Rect;","map":null,"metadata":{},"sourceType":"module"}