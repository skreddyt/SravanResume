{"ast":null,"code":"/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\nimport { BinaryStream, ucs2encode, base64ToUint8Array, HAS_TYPED_ARRAYS } from \"./utils\";\nimport { support } from '../common';\nimport { TTFFont } from \"./ttf\";\nimport { deflate, supportsDeflate } from './deflate';\nvar browser = support.browser;\nvar NL = \"\\n\";\nvar RESOURCE_COUNTER = 0;\nvar PAPER_SIZE = {\n  a0: [2383.94, 3370.39],\n  a1: [1683.78, 2383.94],\n  a2: [1190.55, 1683.78],\n  a3: [841.89, 1190.55],\n  a4: [595.28, 841.89],\n  a5: [419.53, 595.28],\n  a6: [297.64, 419.53],\n  a7: [209.76, 297.64],\n  a8: [147.40, 209.76],\n  a9: [104.88, 147.40],\n  a10: [73.70, 104.88],\n  b0: [2834.65, 4008.19],\n  b1: [2004.09, 2834.65],\n  b2: [1417.32, 2004.09],\n  b3: [1000.63, 1417.32],\n  b4: [708.66, 1000.63],\n  b5: [498.90, 708.66],\n  b6: [354.33, 498.90],\n  b7: [249.45, 354.33],\n  b8: [175.75, 249.45],\n  b9: [124.72, 175.75],\n  b10: [87.87, 124.72],\n  c0: [2599.37, 3676.54],\n  c1: [1836.85, 2599.37],\n  c2: [1298.27, 1836.85],\n  c3: [918.43, 1298.27],\n  c4: [649.13, 918.43],\n  c5: [459.21, 649.13],\n  c6: [323.15, 459.21],\n  c7: [229.61, 323.15],\n  c8: [161.57, 229.61],\n  c9: [113.39, 161.57],\n  c10: [79.37, 113.39],\n  executive: [521.86, 756.00],\n  folio: [612.00, 936.00],\n  legal: [612.00, 1008.00],\n  letter: [612.00, 792.00],\n  tabloid: [792.00, 1224.00]\n};\n\nfunction makeOutput() {\n  var indentLevel = 0,\n      output = BinaryStream();\n\n  function out() {\n    var arguments$1 = arguments;\n\n    for (var i = 0; i < arguments.length; ++i) {\n      var x = arguments$1[i];\n\n      if (x === undefined) {\n        throw new Error(\"Cannot output undefined to PDF\");\n      } else if (x instanceof PDFValue) {\n        x.beforeRender(out);\n        x.render(out);\n      } else if (isArray(x)) {\n        renderArray(x, out);\n      } else if (isDate(x)) {\n        renderDate(x, out);\n      } else if (typeof x == \"number\") {\n        if (isNaN(x)) {\n          throw new Error(\"Cannot output NaN to PDF\");\n        } // make sure it doesn't end up in exponent notation\n\n\n        var num = x.toFixed(7);\n\n        if (num.indexOf(\".\") >= 0) {\n          num = num.replace(/\\.?0+$/, \"\");\n        }\n\n        if (num == \"-0\") {\n          num = \"0\";\n        }\n\n        output.writeString(num);\n      } else if (/string|boolean/.test(typeof x)) {\n        output.writeString(String(x));\n      } else if (typeof x.get == \"function\") {\n        output.write(x.get());\n      } else if (typeof x == \"object\") {\n        if (!x) {\n          output.writeString(\"null\");\n        } else {\n          out(new PDFDictionary(x));\n        }\n      }\n    }\n  }\n\n  out.writeData = function (data) {\n    output.write(data);\n  };\n\n  out.withIndent = function (f) {\n    ++indentLevel;\n    f(out);\n    --indentLevel;\n  };\n\n  out.indent = function () {\n    out(NL, pad(\"\", indentLevel * 2, \"  \"));\n    out.apply(null, arguments);\n  };\n\n  out.offset = function () {\n    return output.offset();\n  };\n\n  out.toString = function () {\n    throw new Error(\"FIX CALLER\");\n  };\n\n  out.get = function () {\n    return output.get();\n  };\n\n  out.stream = function () {\n    return output;\n  };\n\n  return out;\n}\n\nfunction wrapObject(value, id) {\n  var beforeRender = value.beforeRender;\n  var renderValue = value.render;\n\n  value.beforeRender = function () {};\n\n  value.render = function (out) {\n    out(id, \" 0 R\");\n  };\n\n  value.renderFull = function (out) {\n    value._offset = out.offset();\n    out(id, \" 0 obj \");\n    beforeRender.call(value, out);\n    renderValue.call(value, out);\n    out(\" endobj\");\n  };\n}\n\nfunction getPaperOptions(getOption) {\n  if (typeof getOption != \"function\") {\n    var options = getOption;\n\n    getOption = function (key, def) {\n      return key in options ? options[key] : def;\n    };\n  }\n\n  var paperSize = getOption(\"paperSize\", PAPER_SIZE.a4);\n\n  if (!paperSize) {\n    return {};\n  }\n\n  if (typeof paperSize == \"string\") {\n    paperSize = PAPER_SIZE[paperSize.toLowerCase()];\n\n    if (paperSize == null) {\n      throw new Error(\"Unknown paper size\");\n    }\n  }\n\n  paperSize[0] = unitsToPoints(paperSize[0]);\n  paperSize[1] = unitsToPoints(paperSize[1]);\n\n  if (getOption(\"landscape\", false)) {\n    paperSize = [Math.max(paperSize[0], paperSize[1]), Math.min(paperSize[0], paperSize[1])];\n  }\n\n  var margin = getOption(\"margin\");\n\n  if (margin) {\n    if (typeof margin == \"string\" || typeof margin == \"number\") {\n      margin = unitsToPoints(margin, 0);\n      margin = {\n        left: margin,\n        top: margin,\n        right: margin,\n        bottom: margin\n      };\n    } else {\n      margin = {\n        left: unitsToPoints(margin.left, 0),\n        top: unitsToPoints(margin.top, 0),\n        right: unitsToPoints(margin.right, 0),\n        bottom: unitsToPoints(margin.bottom, 0)\n      };\n    }\n\n    if (getOption(\"addMargin\")) {\n      paperSize[0] += margin.left + margin.right;\n      paperSize[1] += margin.top + margin.bottom;\n    }\n  }\n\n  return {\n    paperSize: paperSize,\n    margin: margin\n  };\n}\n\nfunction PDFDocument(options) {\n  var self = this;\n  var out = makeOutput();\n  var objcount = 0;\n  var objects = [];\n\n  function getOption(name, defval) {\n    return options && options[name] != null ? options[name] : defval;\n  }\n\n  self.getOption = getOption;\n\n  self.attach = function (value) {\n    if (objects.indexOf(value) < 0) {\n      wrapObject(value, ++objcount);\n      objects.push(value);\n    }\n\n    return value;\n  };\n\n  self.pages = [];\n  self.FONTS = {};\n  self.IMAGES = {};\n  self.GRAD_COL_FUNCTIONS = {}; // cache for color gradient functions\n\n  self.GRAD_OPC_FUNCTIONS = {}; // cache for opacity gradient functions\n\n  self.GRAD_COL = {}; // cache for whole color gradient objects\n\n  self.GRAD_OPC = {}; // cache for whole opacity gradient objects\n\n  var catalog = self.attach(new PDFCatalog());\n  var pageTree = self.attach(new PDFPageTree());\n\n  if (getOption(\"autoPrint\")) {\n    var nameTree = {};\n    nameTree.JavaScript = new PDFDictionary({\n      Names: [new PDFString(\"JS\"), self.attach(new PDFDictionary({\n        S: _(\"JavaScript\"),\n        JS: new PDFString(\"print(true);\")\n      }))]\n    });\n    catalog.props.Names = new PDFDictionary(nameTree);\n  }\n\n  catalog.setPages(pageTree);\n  var info = self.attach(new PDFDictionary({\n    Producer: new PDFString(getOption(\"producer\", \"Kendo UI PDF Generator\")),\n    // XXX: kendo.version?\n    Title: new PDFString(getOption(\"title\", \"\")),\n    Author: new PDFString(getOption(\"author\", \"\")),\n    Subject: new PDFString(getOption(\"subject\", \"\")),\n    Keywords: new PDFString(getOption(\"keywords\", \"\")),\n    Creator: new PDFString(getOption(\"creator\", \"Kendo UI PDF Generator\")),\n    CreationDate: getOption(\"date\", new Date())\n  }));\n\n  self.addPage = function (options) {\n    var paperOptions = getPaperOptions(function (name, defval) {\n      return options && options[name] != null ? options[name] : defval;\n    });\n    var paperSize = paperOptions.paperSize;\n    var margin = paperOptions.margin;\n    var contentWidth = paperSize[0];\n    var contentHeight = paperSize[1];\n\n    if (margin) {\n      contentWidth -= margin.left + margin.right;\n      contentHeight -= margin.top + margin.bottom;\n    }\n\n    var content = new PDFStream(makeOutput(), null, true);\n    var props = {\n      Contents: self.attach(content),\n      Parent: pageTree,\n      MediaBox: [0, 0, paperSize[0], paperSize[1]]\n    };\n    var page = new PDFPage(self, props);\n    page._content = content;\n    pageTree.addPage(self.attach(page)); // canvas-like coord. system.  (0,0) is upper-left.\n    // text must be vertically mirorred before drawing.\n\n    page.transform(1, 0, 0, -1, 0, paperSize[1]);\n\n    if (margin) {\n      page.translate(margin.left, margin.top); // XXX: clip to right/bottom margin.  Make this optional?\n\n      page.rect(0, 0, contentWidth, contentHeight);\n      page.clip();\n    }\n\n    self.pages.push(page);\n    return page;\n  };\n\n  self.render = function () {\n    var i; /// file header\n\n    out(\"%PDF-1.4\", NL, \"%\\xc2\\xc1\\xda\\xcf\\xce\", NL, NL); /// file body\n\n    for (i = 0; i < objects.length; ++i) {\n      objects[i].renderFull(out);\n      out(NL, NL);\n    } /// cross-reference table\n\n\n    var xrefOffset = out.offset();\n    out(\"xref\", NL, 0, \" \", objects.length + 1, NL);\n    out(\"0000000000 65535 f \", NL);\n\n    for (i = 0; i < objects.length; ++i) {\n      out(zeropad(objects[i]._offset, 10), \" 00000 n \", NL);\n    }\n\n    out(NL); /// trailer\n\n    out(\"trailer\", NL);\n    out(new PDFDictionary({\n      Size: objects.length + 1,\n      Root: catalog,\n      Info: info\n    }), NL, NL); /// end\n\n    out(\"startxref\", NL, xrefOffset, NL);\n    out(\"%%EOF\", NL);\n    return out.stream().offset(0);\n  };\n}\n\nvar FONT_CACHE = {\n  \"Times-Roman\": true,\n  \"Times-Bold\": true,\n  \"Times-Italic\": true,\n  \"Times-BoldItalic\": true,\n  \"Helvetica\": true,\n  \"Helvetica-Bold\": true,\n  \"Helvetica-Oblique\": true,\n  \"Helvetica-BoldOblique\": true,\n  \"Courier\": true,\n  \"Courier-Bold\": true,\n  \"Courier-Oblique\": true,\n  \"Courier-BoldOblique\": true,\n  \"Symbol\": true,\n  \"ZapfDingbats\": true\n};\n\nfunction loadBinary(url, cont) {\n  // IE throws Accesss denied error for Data URIs\n  var m;\n\n  if (browser.msie && (m = /^data:.*?;base64,/i.exec(url))) {\n    cont(base64ToUint8Array(url.substr(m[0].length)));\n    return;\n  }\n\n  function error() {\n    if (window.console) {\n      if (window.console.error) {\n        window.console.error(\"Cannot load URL: %s\", url);\n      } else {\n        window.console.log(\"Cannot load URL: %s\", url);\n      }\n    }\n\n    cont(null);\n  }\n\n  var req = new XMLHttpRequest();\n  req.open('GET', url, true);\n\n  if (HAS_TYPED_ARRAYS) {\n    req.responseType = \"arraybuffer\";\n  }\n\n  req.onload = function () {\n    if (req.status == 200 || req.status == 304) {\n      if (HAS_TYPED_ARRAYS) {\n        cont(new Uint8Array(req.response));\n      } else {\n        cont(new window.VBArray(req.responseBody).toArray()); // IE9 only\n      }\n    } else {\n      error();\n    }\n  };\n\n  req.onerror = error;\n  req.send(null);\n}\n\nfunction loadFont(url, cont) {\n  var font = FONT_CACHE[url];\n\n  if (font) {\n    cont(font);\n  } else {\n    loadBinary(url, function (data) {\n      if (data == null) {\n        throw new Error(\"Cannot load font from \" + url);\n      } else {\n        var font = new TTFFont(data);\n        FONT_CACHE[url] = font;\n        cont(font);\n      }\n    });\n  }\n}\n\nvar IMAGE_CACHE = {};\n\nfunction clearImageCache() {\n  IMAGE_CACHE = {};\n}\n\nfunction loadImage(url, size, cont) {\n  var img = IMAGE_CACHE[url],\n      bloburl,\n      blob;\n\n  if (img) {\n    cont(img);\n  } else {\n    img = new Image();\n\n    if (!/^data:/i.test(url)) {\n      img.crossOrigin = \"Anonymous\";\n    }\n\n    if (HAS_TYPED_ARRAYS && !/^data:/i.test(url)) {\n      // IE10 fails to load images from another domain even when the server sends the\n      // proper CORS headers.  a XHR, however, will be able to load the data.\n      // http://stackoverflow.com/a/19734516/154985\n      //\n      // On the other hand, it's worth doing it this way for all browsers which support\n      // responseType = \"blob\" (HAS_TYPED_ARRAYS will be true), because we can inspect the\n      // mime type and if it's a JPEG (very common case) we can save a lot of time in\n      // _load below.\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function () {\n        blob = xhr.response;\n        bloburl = URL.createObjectURL(blob);\n\n        _load(bloburl);\n      };\n\n      xhr.onerror = _onerror;\n      xhr.open(\"GET\", url, true);\n      xhr.responseType = \"blob\";\n      xhr.send();\n    } else {\n      _load(url);\n    }\n  }\n\n  function _load(url) {\n    img.src = url;\n\n    if (img.complete && !browser.msie) {\n      // IE, bless it's little heart, says img.complete == true even though the image is\n      // not loaded (width=0), therefore we must go the onload route (ticket 929635).\n      _onload();\n    } else {\n      img.onload = _onload;\n      img.onerror = _onerror;\n    }\n  }\n\n  function _trycanvas() {\n    if (!size) {\n      size = {\n        width: img.width,\n        height: img.height\n      };\n    }\n\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = size.width;\n    canvas.height = size.height;\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img, 0, 0, size.width, size.height);\n    var imgdata;\n\n    try {\n      imgdata = ctx.getImageData(0, 0, size.width, size.height);\n    } catch (ex) {\n      // it tainted the canvas -- can't draw it.\n      _onerror();\n\n      return;\n    } finally {\n      if (bloburl) {\n        URL.revokeObjectURL(bloburl);\n      }\n    } // in case it contains transparency, we must separate rgb data from the alpha\n    // channel and create a PDFRawImage image with opacity.  otherwise we can use a\n    // PDFJpegImage.\n    //\n    // to do this in one step, we create the rgb and alpha streams anyway, even if\n    // we might end up not using them if hasAlpha remains false.\n\n\n    var hasAlpha = false,\n        rgb = BinaryStream(),\n        alpha = BinaryStream();\n    var rawbytes = imgdata.data;\n    var i = 0;\n\n    while (i < rawbytes.length) {\n      rgb.writeByte(rawbytes[i++]);\n      rgb.writeByte(rawbytes[i++]);\n      rgb.writeByte(rawbytes[i++]);\n      var a = rawbytes[i++];\n\n      if (a < 255) {\n        hasAlpha = true;\n      }\n\n      alpha.writeByte(a);\n    }\n\n    if (hasAlpha) {\n      img = new PDFRawImage(size.width, size.height, rgb, alpha);\n    } else {\n      // no transparency, encode as JPEG.\n      var data = canvas.toDataURL(\"image/jpeg\");\n      data = data.substr(data.indexOf(\";base64,\") + 8);\n      var stream = BinaryStream();\n      stream.writeBase64(data);\n      img = new PDFJpegImage(stream);\n    }\n\n    cont(IMAGE_CACHE[url] = img);\n  }\n\n  function _onerror() {\n    cont(IMAGE_CACHE[url] = \"ERROR\");\n  }\n\n  function _onload() {\n    if (size) {\n      // but if requested size is bigger than the image, just use the original image.\n      if (size.width >= img.width || size.height >= img.height) {\n        size = null;\n      }\n    }\n\n    if (!size && blob && /^image\\/jpe?g$/i.test(blob.type)) {\n      // If we know we got a JPEG, we can skip the process of rendering it to a\n      // canvas, getting the pixel data, searching for transparency we know we won't\n      // find, getting back a data URI and then decoding the BASE64 to finally get the\n      // binary we already have.  Also, we avoid downgrading the image quality, with\n      // the possible drawback of making a bigger PDF; still, seems legit.\n      //\n      // Besides saving a lot of work, this also reuses the buffer memory\n      // (BinaryStream does not create a copy), potentially saving some GC cycles.\n      var reader = new FileReader();\n\n      reader.onload = function () {\n        try {\n          var img = new PDFJpegImage(BinaryStream(new Uint8Array(this.result)));\n          URL.revokeObjectURL(bloburl);\n          cont(IMAGE_CACHE[url] = img);\n        } catch (ex) {\n          // if there's an error parsing the JPEG stream, it could be due to a\n          // misconfigured server (improper content-type:\n          // https://github.com/telerik/kendo-ui-core/issues/4184).  If that's the case,\n          // the canvas will still be able to draw it.\n          _trycanvas();\n        }\n      };\n\n      reader.readAsArrayBuffer(blob);\n    } else {\n      _trycanvas();\n    }\n  }\n}\n\nfunction manyLoader(loadOne) {\n  return function (urls, callback) {\n    var n = urls.length,\n        i = n;\n\n    if (n === 0) {\n      return callback();\n    }\n\n    function next() {\n      if (--n === 0) {\n        callback();\n      }\n    }\n\n    while (i-- > 0) {\n      loadOne(urls[i], next);\n    }\n  };\n}\n\nvar loadFonts = manyLoader(loadFont);\n\nvar loadImages = function (images, callback) {\n  var urls = Object.keys(images),\n      n = urls.length;\n\n  if (n === 0) {\n    return callback();\n  }\n\n  function next() {\n    if (--n === 0) {\n      callback();\n    }\n  }\n\n  urls.forEach(function (url) {\n    loadImage(url, images[url], next);\n  });\n};\n\nPDFDocument.prototype = {\n  loadFonts: loadFonts,\n  loadImages: loadImages,\n  getFont: function (url) {\n    var font = this.FONTS[url];\n\n    if (!font) {\n      font = FONT_CACHE[url];\n\n      if (!font) {\n        throw new Error(\"Font \" + url + \" has not been loaded\");\n      }\n\n      if (font === true) {\n        font = this.attach(new PDFStandardFont(url));\n      } else {\n        font = this.attach(new PDFFont(this, font));\n      }\n\n      this.FONTS[url] = font;\n    }\n\n    return font;\n  },\n  getImage: function (url) {\n    var img = this.IMAGES[url];\n\n    if (!img) {\n      img = IMAGE_CACHE[url];\n\n      if (!img) {\n        throw new Error(\"Image \" + url + \" has not been loaded\");\n      }\n\n      if (img === \"ERROR\") {\n        return null;\n      }\n\n      img = this.IMAGES[url] = this.attach(img.asStream(this));\n    }\n\n    return img;\n  },\n  getOpacityGS: function (opacity, forStroke) {\n    var id = parseFloat(opacity).toFixed(3);\n    opacity = parseFloat(id);\n    id += forStroke ? \"S\" : \"F\";\n    var cache = this._opacityGSCache || (this._opacityGSCache = {});\n    var gs = cache[id];\n\n    if (!gs) {\n      var props = {\n        Type: _(\"ExtGState\")\n      };\n\n      if (forStroke) {\n        props.CA = opacity;\n      } else {\n        props.ca = opacity;\n      }\n\n      gs = this.attach(new PDFDictionary(props));\n      gs._resourceName = _(\"GS\" + ++RESOURCE_COUNTER);\n      cache[id] = gs;\n    }\n\n    return gs;\n  },\n  dict: function (props) {\n    return new PDFDictionary(props);\n  },\n  name: function (str) {\n    return _(str);\n  },\n  stream: function (props, content) {\n    return new PDFStream(content, props);\n  }\n};\n/* -----[ utils ]----- */\n\nfunction pad(str, len, ch) {\n  while (str.length < len) {\n    str = ch + str;\n  }\n\n  return str;\n}\n\nfunction zeropad(n, len) {\n  return pad(String(n), len, \"0\");\n}\n\nfunction hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return obj instanceof Array;\n};\n\nfunction isDate(obj) {\n  return obj instanceof Date;\n}\n\nfunction renderArray(a, out) {\n  out(\"[\");\n\n  if (a.length > 0) {\n    out.withIndent(function () {\n      for (var i = 0; i < a.length; ++i) {\n        if (i > 0 && i % 8 === 0) {\n          out.indent(a[i]);\n        } else {\n          out(\" \", a[i]);\n        }\n      }\n    }); //out.indent();\n  }\n\n  out(\" ]\");\n}\n\nfunction renderDate(date, out) {\n  out(\"(D:\", zeropad(date.getUTCFullYear(), 4), zeropad(date.getUTCMonth() + 1, 2), zeropad(date.getUTCDate(), 2), zeropad(date.getUTCHours(), 2), zeropad(date.getUTCMinutes(), 2), zeropad(date.getUTCSeconds(), 2), \"Z)\");\n}\n\nfunction mm2pt(mm) {\n  return mm * (72 / 25.4);\n}\n\nfunction cm2pt(cm) {\n  return mm2pt(cm * 10);\n}\n\nfunction in2pt(inch) {\n  return inch * 72;\n}\n\nfunction unitsToPoints(x, def) {\n  if (typeof x == \"number\") {\n    return x;\n  }\n\n  if (typeof x == \"string\") {\n    var m;\n    m = /^\\s*([0-9.]+)\\s*(mm|cm|in|pt)\\s*$/.exec(x);\n\n    if (m) {\n      var num = parseFloat(m[1]);\n\n      if (!isNaN(num)) {\n        if (m[2] == \"pt\") {\n          return num;\n        }\n\n        return {\n          \"mm\": mm2pt,\n          \"cm\": cm2pt,\n          \"in\": in2pt\n        }[m[2]](num);\n      }\n    }\n  }\n\n  if (def != null) {\n    return def;\n  }\n\n  throw new Error(\"Can't parse unit: \" + x);\n}\n/* -----[ PDF basic objects ]----- */\n\n\nfunction PDFValue() {}\n\nPDFValue.prototype.beforeRender = function () {};\n\nfunction defclass(Ctor, proto, Base) {\n  if (!Base) {\n    Base = PDFValue;\n  }\n\n  Ctor.prototype = new Base();\n\n  for (var i in proto) {\n    if (hasOwnProperty(proto, i)) {\n      Ctor.prototype[i] = proto[i];\n    }\n  }\n\n  return Ctor;\n} /// strings\n\n\nvar PDFString = defclass(function PDFString(value) {\n  this.value = value;\n}, {\n  render: function (out) {\n    var txt = \"\",\n        val = this.value;\n\n    for (var i = 0; i < val.length; ++i) {\n      txt += String.fromCharCode(val.charCodeAt(i) & 0xFF);\n    }\n\n    out(\"(\", txt.replace(/([\\(\\)\\\\])/g, \"\\\\$1\"), \")\");\n  },\n  toString: function () {\n    return this.value;\n  }\n});\nvar PDFHexString = defclass(function PDFHexString(value) {\n  this.value = value;\n}, {\n  render: function (out) {\n    var this$1 = this;\n    out(\"<\");\n\n    for (var i = 0; i < this.value.length; ++i) {\n      out(zeropad(this$1.value.charCodeAt(i).toString(16), 4));\n    }\n\n    out(\">\");\n  }\n}, PDFString); /// names\n\nvar PDFName = defclass(function PDFName(name) {\n  this.name = name;\n}, {\n  render: function (out) {\n    out(\"/\" + this.escape());\n  },\n  escape: function () {\n    return this.name.replace(/[^\\x21-\\x7E]/g, function (c) {\n      return \"#\" + zeropad(c.charCodeAt(0).toString(16), 2);\n    });\n  },\n  toString: function () {\n    return this.name;\n  }\n});\nvar PDFName_cache = {};\nPDFName.get = _;\n\nfunction _(name) {\n  if (hasOwnProperty(PDFName_cache, name)) {\n    return PDFName_cache[name];\n  }\n\n  return PDFName_cache[name] = new PDFName(name);\n} /// dictionary\n\n\nvar PDFDictionary = defclass(function PDFDictionary(props) {\n  this.props = props;\n}, {\n  render: function (out) {\n    var props = this.props,\n        empty = true;\n    out(\"<<\");\n    out.withIndent(function () {\n      for (var i in props) {\n        if (hasOwnProperty(props, i) && !/^_/.test(i)) {\n          empty = false;\n          out.indent(_(i), \" \", props[i]);\n        }\n      }\n    });\n\n    if (!empty) {\n      out.indent();\n    }\n\n    out(\">>\");\n  }\n}); /// streams\n\nvar PDFStream = defclass(function PDFStream(data, props, compress) {\n  if (typeof data == \"string\") {\n    var tmp = BinaryStream();\n    tmp.write(data);\n    data = tmp;\n  }\n\n  this.data = data;\n  this.props = props || {};\n  this.compress = compress;\n}, {\n  render: function (out) {\n    var data = this.data.get(),\n        props = this.props;\n\n    if (this.compress && supportsDeflate()) {\n      if (!props.Filter) {\n        props.Filter = [];\n      } else if (!(props.Filter instanceof Array)) {\n        props.Filter = [props.Filter];\n      }\n\n      props.Filter.unshift(_(\"FlateDecode\"));\n      data = deflate(data);\n    }\n\n    props.Length = data.length;\n    out(new PDFDictionary(props), \" stream\", NL);\n    out.writeData(data);\n    out(NL, \"endstream\");\n  }\n}); /// catalog\n\nvar PDFCatalog = defclass(function PDFCatalog() {\n  this.props = {\n    Type: _(\"Catalog\")\n  };\n}, {\n  setPages: function (pagesObj) {\n    this.props.Pages = pagesObj;\n  }\n}, PDFDictionary); /// page tree\n\nvar PDFPageTree = defclass(function PDFPageTree() {\n  this.props = {\n    Type: _(\"Pages\"),\n    Kids: [],\n    Count: 0\n  };\n}, {\n  addPage: function (pageObj) {\n    this.props.Kids.push(pageObj);\n    this.props.Count++;\n  }\n}, PDFDictionary); /// images\n// JPEG\n\nvar SOF_CODES = [0xc0, 0xc1, 0xc2, 0xc3, 0xc5, 0xc6, 0xc7, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf];\n\nfunction PDFJpegImage(data) {\n  // we must determine the correct color space.  we'll parse a bit\n  // of the JPEG stream for this, it's still better than going\n  // through the canvas.\n  // https://github.com/telerik/kendo-ui-core/issues/2845\n  data.offset(0);\n  var width, height, colorSpace, bitsPerComponent;\n  var soi = data.readShort();\n\n  if (soi != 0xFFD8) {\n    // XXX: do we have some better options here?\n    throw new Error(\"Invalid JPEG image\");\n  }\n\n  while (!data.eof()) {\n    var ff = data.readByte();\n\n    if (ff != 0xFF) {\n      throw new Error(\"Invalid JPEG image\");\n    }\n\n    var marker = data.readByte();\n    var length = data.readShort();\n\n    if (SOF_CODES.indexOf(marker) >= 0) {\n      // \"start of frame\" marker\n      bitsPerComponent = data.readByte();\n      height = data.readShort();\n      width = data.readShort();\n      colorSpace = data.readByte();\n      break;\n    }\n\n    data.skip(length - 2);\n  }\n\n  if (colorSpace == null) {\n    throw new Error(\"Invalid JPEG image\");\n  }\n\n  var props = {\n    Type: _(\"XObject\"),\n    Subtype: _(\"Image\"),\n    Width: width,\n    Height: height,\n    BitsPerComponent: bitsPerComponent,\n    Filter: _(\"DCTDecode\")\n  };\n\n  switch (colorSpace) {\n    case 1:\n      props.ColorSpace = _(\"DeviceGray\");\n      break;\n\n    case 3:\n      props.ColorSpace = _(\"DeviceRGB\");\n      break;\n\n    case 4:\n      props.ColorSpace = _(\"DeviceCMYK\");\n      props.Decode = [1, 0, 1, 0, 1, 0, 1, 0]; // invert colors\n\n      break;\n  }\n\n  this.asStream = function () {\n    data.offset(0);\n    var stream = new PDFStream(data, props);\n    stream._resourceName = _(\"I\" + ++RESOURCE_COUNTER);\n    return stream;\n  };\n} // PDFRawImage will be used for images with transparency (PNG)\n\n\nfunction PDFRawImage(width, height, rgb, alpha) {\n  this.asStream = function (pdf) {\n    var mask = new PDFStream(alpha, {\n      Type: _(\"XObject\"),\n      Subtype: _(\"Image\"),\n      Width: width,\n      Height: height,\n      BitsPerComponent: 8,\n      ColorSpace: _(\"DeviceGray\")\n    }, true);\n    var stream = new PDFStream(rgb, {\n      Type: _(\"XObject\"),\n      Subtype: _(\"Image\"),\n      Width: width,\n      Height: height,\n      BitsPerComponent: 8,\n      ColorSpace: _(\"DeviceRGB\"),\n      SMask: pdf.attach(mask)\n    }, true);\n    stream._resourceName = _(\"I\" + ++RESOURCE_COUNTER);\n    return stream;\n  };\n} /// standard fonts\n\n\nvar PDFStandardFont = defclass(function PDFStandardFont(name) {\n  this.props = {\n    Type: _(\"Font\"),\n    Subtype: _(\"Type1\"),\n    BaseFont: _(name)\n  };\n  this._resourceName = _(\"F\" + ++RESOURCE_COUNTER);\n}, {\n  encodeText: function (str) {\n    return new PDFString(String(str));\n  }\n}, PDFDictionary); /// TTF fonts\n\nvar PDFFont = defclass(function PDFFont(pdf, font, props) {\n  props = this.props = props || {};\n  props.Type = _(\"Font\");\n  props.Subtype = _(\"Type0\");\n  props.Encoding = _(\"Identity-H\");\n  this._pdf = pdf;\n  this._font = font;\n  this._sub = font.makeSubset();\n  this._resourceName = _(\"F\" + ++RESOURCE_COUNTER);\n  var head = font.head;\n  this.name = font.psName;\n  var scale = this.scale = font.scale;\n  this.bbox = [head.xMin * scale, head.yMin * scale, head.xMax * scale, head.yMax * scale];\n  this.italicAngle = font.post.italicAngle;\n  this.ascent = font.ascent * scale;\n  this.descent = font.descent * scale;\n  this.lineGap = font.lineGap * scale;\n  this.capHeight = font.os2.capHeight || this.ascent;\n  this.xHeight = font.os2.xHeight || 0;\n  this.stemV = 0;\n  this.familyClass = (font.os2.familyClass || 0) >> 8;\n  this.isSerif = this.familyClass >= 1 && this.familyClass <= 7;\n  this.isScript = this.familyClass == 10;\n  this.flags = (font.post.isFixedPitch ? 1 : 0) | (this.isSerif ? 1 << 1 : 0) | (this.isScript ? 1 << 3 : 0) | (this.italicAngle !== 0 ? 1 << 6 : 0) | 1 << 5;\n}, {\n  encodeText: function (text) {\n    return new PDFHexString(this._sub.encodeText(String(text)));\n  },\n  getTextWidth: function (fontSize, text) {\n    var this$1 = this;\n    var width = 0,\n        codeMap = this._font.cmap.codeMap;\n\n    for (var i = 0; i < text.length; ++i) {\n      var glyphId = codeMap[text.charCodeAt(i)];\n      width += this$1._font.widthOfGlyph(glyphId || 0);\n    }\n\n    return width * fontSize / 1000;\n  },\n  beforeRender: function () {\n    var self = this;\n    var sub = self._sub; // write the TTF data\n\n    var data = sub.render();\n    var fontStream = new PDFStream(BinaryStream(data), {\n      Length1: data.length\n    }, true);\n\n    var descriptor = self._pdf.attach(new PDFDictionary({\n      Type: _(\"FontDescriptor\"),\n      FontName: _(self._sub.psName),\n      FontBBox: self.bbox,\n      Flags: self.flags,\n      StemV: self.stemV,\n      ItalicAngle: self.italicAngle,\n      Ascent: self.ascent,\n      Descent: self.descent,\n      CapHeight: self.capHeight,\n      XHeight: self.xHeight,\n      FontFile2: self._pdf.attach(fontStream)\n    }));\n\n    var cmap = sub.ncid2ogid;\n    var firstChar = sub.firstChar;\n    var lastChar = sub.lastChar;\n    var charWidths = [];\n\n    (function loop(i, chunk) {\n      if (i <= lastChar) {\n        var gid = cmap[i];\n\n        if (gid == null) {\n          loop(i + 1);\n        } else {\n          if (!chunk) {\n            charWidths.push(i, chunk = []);\n          }\n\n          chunk.push(self._font.widthOfGlyph(gid));\n          loop(i + 1, chunk);\n        }\n      }\n    })(firstChar); // As if two dictionaries weren't enough, we need another\n    // one, the \"descendant font\".  Only that one can be of\n    // Subtype CIDFontType2.  PDF is the X11 of document\n    // formats: portable but full of legacy that nobody cares\n    // about anymore.\n\n\n    var descendant = new PDFDictionary({\n      Type: _(\"Font\"),\n      Subtype: _(\"CIDFontType2\"),\n      BaseFont: _(self._sub.psName),\n      CIDSystemInfo: new PDFDictionary({\n        Registry: new PDFString(\"Adobe\"),\n        Ordering: new PDFString(\"Identity\"),\n        Supplement: 0\n      }),\n      FontDescriptor: descriptor,\n      FirstChar: firstChar,\n      LastChar: lastChar,\n      DW: Math.round(self._font.widthOfGlyph(0)),\n      W: charWidths,\n      CIDToGIDMap: self._pdf.attach(self._makeCidToGidMap())\n    });\n    var dict = self.props;\n    dict.BaseFont = _(self._sub.psName);\n    dict.DescendantFonts = [self._pdf.attach(descendant)]; // Compute the ToUnicode map so that apps can extract\n    // meaningful text from the PDF.\n\n    var unimap = new PDFToUnicodeCmap(firstChar, lastChar, sub.subset);\n    var unimapStream = new PDFStream(makeOutput(), null, true);\n    unimapStream.data(unimap);\n    dict.ToUnicode = self._pdf.attach(unimapStream);\n  },\n  _makeCidToGidMap: function () {\n    return new PDFStream(BinaryStream(this._sub.cidToGidMap()), null, true);\n  }\n}, PDFDictionary);\nvar PDFToUnicodeCmap = defclass(function PDFUnicodeCMap(firstChar, lastChar, map) {\n  this.firstChar = firstChar;\n  this.lastChar = lastChar;\n  this.map = map;\n}, {\n  render: function (out) {\n    out.indent(\"/CIDInit /ProcSet findresource begin\");\n    out.indent(\"12 dict begin\");\n    out.indent(\"begincmap\");\n    out.indent(\"/CIDSystemInfo <<\");\n    out.indent(\"  /Registry (Adobe)\");\n    out.indent(\"  /Ordering (UCS)\");\n    out.indent(\"  /Supplement 0\");\n    out.indent(\">> def\");\n    out.indent(\"/CMapName /Adobe-Identity-UCS def\");\n    out.indent(\"/CMapType 2 def\");\n    out.indent(\"1 begincodespacerange\");\n    out.indent(\"  <0000><ffff>\");\n    out.indent(\"endcodespacerange\");\n    var self = this;\n    out.indent(self.lastChar - self.firstChar + 1, \" beginbfchar\");\n    out.withIndent(function () {\n      for (var code = self.firstChar; code <= self.lastChar; ++code) {\n        var unicode = self.map[code];\n        var str = ucs2encode([unicode]);\n        out.indent(\"<\", zeropad(code.toString(16), 4), \">\", \"<\");\n\n        for (var i = 0; i < str.length; ++i) {\n          out(zeropad(str.charCodeAt(i).toString(16), 4));\n        }\n\n        out(\">\");\n      }\n    });\n    out.indent(\"endbfchar\");\n    out.indent(\"endcmap\");\n    out.indent(\"CMapName currentdict /CMap defineresource pop\");\n    out.indent(\"end\");\n    out.indent(\"end\");\n  }\n}); /// gradients\n\nfunction makeHash(a) {\n  return a.map(function (x) {\n    return isArray(x) ? makeHash(x) : typeof x == \"number\" ? (Math.round(x * 1000) / 1000).toFixed(3) : x;\n  }).join(\" \");\n}\n\nfunction cacheColorGradientFunction(pdf, r1, g1, b1, r2, g2, b2) {\n  var hash = makeHash([r1, g1, b1, r2, g2, b2]);\n  var func = pdf.GRAD_COL_FUNCTIONS[hash];\n\n  if (!func) {\n    func = pdf.GRAD_COL_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({\n      FunctionType: 2,\n      Domain: [0, 1],\n      Range: [0, 1, 0, 1, 0, 1],\n      N: 1,\n      C0: [r1, g1, b1],\n      C1: [r2, g2, b2]\n    }));\n  }\n\n  return func;\n}\n\nfunction cacheOpacityGradientFunction(pdf, a1, a2) {\n  var hash = makeHash([a1, a2]);\n  var func = pdf.GRAD_OPC_FUNCTIONS[hash];\n\n  if (!func) {\n    func = pdf.GRAD_OPC_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({\n      FunctionType: 2,\n      Domain: [0, 1],\n      Range: [0, 1],\n      N: 1,\n      C0: [a1],\n      C1: [a2]\n    }));\n  }\n\n  return func;\n}\n\nfunction makeGradientFunctions(pdf, stops) {\n  var hasAlpha = false;\n  var opacities = [];\n  var colors = [];\n  var offsets = [];\n  var encode = [];\n  var i, prev, cur, prevColor, curColor;\n\n  for (i = 1; i < stops.length; ++i) {\n    prev = stops[i - 1];\n    cur = stops[i];\n    prevColor = prev.color;\n    curColor = cur.color;\n    colors.push(cacheColorGradientFunction(pdf, prevColor.r, prevColor.g, prevColor.b, curColor.r, curColor.g, curColor.b));\n\n    if (prevColor.a < 1 || curColor.a < 1) {\n      hasAlpha = true;\n    }\n\n    offsets.push(cur.offset);\n    encode.push(0, 1);\n  }\n\n  if (hasAlpha) {\n    for (i = 1; i < stops.length; ++i) {\n      prev = stops[i - 1];\n      cur = stops[i];\n      prevColor = prev.color;\n      curColor = cur.color;\n      opacities.push(cacheOpacityGradientFunction(pdf, prevColor.a, curColor.a));\n    }\n  }\n\n  offsets.pop();\n  return {\n    hasAlpha: hasAlpha,\n    colors: assemble(colors),\n    opacities: hasAlpha ? assemble(opacities) : null\n  };\n\n  function assemble(funcs) {\n    if (funcs.length == 1) {\n      return funcs[0];\n    }\n\n    return {\n      FunctionType: 3,\n      Functions: funcs,\n      Domain: [0, 1],\n      Bounds: offsets,\n      Encode: encode\n    };\n  }\n}\n\nfunction cacheColorGradient(pdf, isRadial, stops, coords, funcs, box) {\n  var shading, hash; // if box is given then we have user-space coordinates, which\n  // means the gradient is designed for a certain position/size\n  // on page.  caching won't do any good.\n\n  if (!box) {\n    var a = [isRadial].concat(coords);\n    stops.forEach(function (x) {\n      a.push(x.offset, x.color.r, x.color.g, x.color.b);\n    });\n    hash = makeHash(a);\n    shading = pdf.GRAD_COL[hash];\n  }\n\n  if (!shading) {\n    shading = new PDFDictionary({\n      Type: _(\"Shading\"),\n      ShadingType: isRadial ? 3 : 2,\n      ColorSpace: _(\"DeviceRGB\"),\n      Coords: coords,\n      Domain: [0, 1],\n      Function: funcs,\n      Extend: [true, true]\n    });\n    pdf.attach(shading);\n    shading._resourceName = \"S\" + ++RESOURCE_COUNTER;\n\n    if (hash) {\n      pdf.GRAD_COL[hash] = shading;\n    }\n  }\n\n  return shading;\n}\n\nfunction cacheOpacityGradient(pdf, isRadial, stops, coords, funcs, box) {\n  var opacity, hash; // if box is given then we have user-space coordinates, which\n  // means the gradient is designed for a certain position/size\n  // on page.  caching won't do any good.\n\n  if (!box) {\n    var a = [isRadial].concat(coords);\n    stops.forEach(function (x) {\n      a.push(x.offset, x.color.a);\n    });\n    hash = makeHash(a);\n    opacity = pdf.GRAD_OPC[hash];\n  }\n\n  if (!opacity) {\n    opacity = new PDFDictionary({\n      Type: _(\"ExtGState\"),\n      AIS: false,\n      CA: 1,\n      ca: 1,\n      SMask: {\n        Type: _(\"Mask\"),\n        S: _(\"Luminosity\"),\n        G: pdf.attach(new PDFStream(\"/a0 gs /s0 sh\", {\n          Type: _(\"XObject\"),\n          Subtype: _(\"Form\"),\n          FormType: 1,\n          BBox: box ? [box.left, box.top + box.height, box.left + box.width, box.top] : [0, 1, 1, 0],\n          Group: {\n            Type: _(\"Group\"),\n            S: _(\"Transparency\"),\n            CS: _(\"DeviceGray\"),\n            I: true\n          },\n          Resources: {\n            ExtGState: {\n              a0: {\n                CA: 1,\n                ca: 1\n              }\n            },\n            Shading: {\n              s0: {\n                ColorSpace: _(\"DeviceGray\"),\n                Coords: coords,\n                Domain: [0, 1],\n                ShadingType: isRadial ? 3 : 2,\n                Function: funcs,\n                Extend: [true, true]\n              }\n            }\n          }\n        }))\n      }\n    });\n    pdf.attach(opacity);\n    opacity._resourceName = \"O\" + ++RESOURCE_COUNTER;\n\n    if (hash) {\n      pdf.GRAD_OPC[hash] = opacity;\n    }\n  }\n\n  return opacity;\n}\n\nfunction cacheGradient(pdf, gradient, box) {\n  var isRadial = gradient.type == \"radial\";\n  var funcs = makeGradientFunctions(pdf, gradient.stops);\n  var coords = isRadial ? [gradient.start.x, gradient.start.y, gradient.start.r, gradient.end.x, gradient.end.y, gradient.end.r] : [gradient.start.x, gradient.start.y, gradient.end.x, gradient.end.y];\n  var shading = cacheColorGradient(pdf, isRadial, gradient.stops, coords, funcs.colors, gradient.userSpace && box);\n  var opacity = funcs.hasAlpha ? cacheOpacityGradient(pdf, isRadial, gradient.stops, coords, funcs.opacities, gradient.userSpace && box) : null;\n  return {\n    hasAlpha: funcs.hasAlpha,\n    shading: shading,\n    opacity: opacity\n  };\n} /// page object\n\n\nvar PDFPage = defclass(function PDFPage(pdf, props) {\n  this._pdf = pdf;\n  this._rcount = 0;\n  this._textMode = false;\n  this._fontResources = {};\n  this._gsResources = {};\n  this._xResources = {};\n  this._patResources = {};\n  this._shResources = {};\n  this._opacity = 1;\n  this._matrix = [1, 0, 0, 1, 0, 0];\n  this._annotations = [];\n  this._font = null;\n  this._fontSize = null;\n  this._contextStack = [];\n  props = this.props = props || {};\n  props.Type = _(\"Page\");\n  props.ProcSet = [_(\"PDF\"), _(\"Text\"), _(\"ImageB\"), _(\"ImageC\"), _(\"ImageI\")];\n  props.Resources = new PDFDictionary({\n    Font: new PDFDictionary(this._fontResources),\n    ExtGState: new PDFDictionary(this._gsResources),\n    XObject: new PDFDictionary(this._xResources),\n    Pattern: new PDFDictionary(this._patResources),\n    Shading: new PDFDictionary(this._shResources)\n  });\n  props.Annots = this._annotations;\n}, {\n  _out: function () {\n    this._content.data.apply(null, arguments);\n  },\n  transform: function (a, b, c, d, e, f) {\n    if (!isIdentityMatrix(arguments)) {\n      this._matrix = mmul(arguments, this._matrix);\n\n      this._out(a, \" \", b, \" \", c, \" \", d, \" \", e, \" \", f, \" cm\"); // XXX: debug\n      // this._out(\" % current matrix: \", this._matrix);\n\n\n      this._out(NL);\n    }\n  },\n  translate: function (dx, dy) {\n    this.transform(1, 0, 0, 1, dx, dy);\n  },\n  scale: function (sx, sy) {\n    this.transform(sx, 0, 0, sy, 0, 0);\n  },\n  rotate: function (angle) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n    this.transform(cos, sin, -sin, cos, 0, 0);\n  },\n  beginText: function () {\n    this._textMode = true;\n\n    this._out(\"BT\", NL);\n  },\n  endText: function () {\n    this._textMode = false;\n\n    this._out(\"ET\", NL);\n  },\n  _requireTextMode: function () {\n    if (!this._textMode) {\n      throw new Error(\"Text mode required; call page.beginText() first\");\n    }\n  },\n  _requireFont: function () {\n    if (!this._font) {\n      throw new Error(\"No font selected; call page.setFont() first\");\n    }\n  },\n  setFont: function (font, size) {\n    this._requireTextMode();\n\n    if (font == null) {\n      font = this._font;\n    } else if (!(font instanceof PDFFont)) {\n      font = this._pdf.getFont(font);\n    }\n\n    if (size == null) {\n      size = this._fontSize;\n    }\n\n    this._fontResources[font._resourceName] = font;\n    this._font = font;\n    this._fontSize = size;\n\n    this._out(font._resourceName, \" \", size, \" Tf\", NL);\n  },\n  setTextLeading: function (size) {\n    this._requireTextMode();\n\n    this._out(size, \" TL\", NL);\n  },\n  setTextRenderingMode: function (mode) {\n    this._requireTextMode();\n\n    this._out(mode, \" Tr\", NL);\n  },\n  showText: function (text, requestedWidth) {\n    this._requireFont();\n\n    if (text.length > 1 && requestedWidth && this._font instanceof PDFFont) {\n      var outputWidth = this._font.getTextWidth(this._fontSize, text);\n\n      var scale = requestedWidth / outputWidth * 100;\n\n      this._out(scale, \" Tz \");\n    }\n\n    this._out(this._font.encodeText(text), \" Tj\", NL);\n  },\n  showTextNL: function (text) {\n    this._requireFont();\n\n    this._out(this._font.encodeText(text), \" '\", NL);\n  },\n  addLink: function (uri, box) {\n    var ll = this._toPage({\n      x: box.left,\n      y: box.bottom\n    });\n\n    var ur = this._toPage({\n      x: box.right,\n      y: box.top\n    });\n\n    this._annotations.push(new PDFDictionary({\n      Type: _(\"Annot\"),\n      Subtype: _(\"Link\"),\n      Rect: [ll.x, ll.y, ur.x, ur.y],\n      Border: [0, 0, 0],\n      A: new PDFDictionary({\n        Type: _(\"Action\"),\n        S: _(\"URI\"),\n        URI: new PDFString(uri)\n      })\n    }));\n  },\n  setStrokeColor: function (r, g, b) {\n    this._out(r, \" \", g, \" \", b, \" RG\", NL);\n  },\n  setOpacity: function (opacity) {\n    this.setFillOpacity(opacity);\n    this.setStrokeOpacity(opacity);\n    this._opacity *= opacity;\n  },\n  setStrokeOpacity: function (opacity) {\n    if (opacity < 1) {\n      var gs = this._pdf.getOpacityGS(this._opacity * opacity, true);\n\n      this._gsResources[gs._resourceName] = gs;\n\n      this._out(gs._resourceName, \" gs\", NL);\n    }\n  },\n  setFillColor: function (r, g, b) {\n    this._out(r, \" \", g, \" \", b, \" rg\", NL);\n  },\n  setFillOpacity: function (opacity) {\n    if (opacity < 1) {\n      var gs = this._pdf.getOpacityGS(this._opacity * opacity, false);\n\n      this._gsResources[gs._resourceName] = gs;\n\n      this._out(gs._resourceName, \" gs\", NL);\n    }\n  },\n  gradient: function (gradient, box) {\n    this.save();\n    this.rect(box.left, box.top, box.width, box.height);\n    this.clip();\n\n    if (!gradient.userSpace) {\n      this.transform(box.width, 0, 0, box.height, box.left, box.top);\n    }\n\n    var g = cacheGradient(this._pdf, gradient, box);\n    var sname = g.shading._resourceName,\n        oname;\n    this._shResources[sname] = g.shading;\n\n    if (g.hasAlpha) {\n      oname = g.opacity._resourceName;\n      this._gsResources[oname] = g.opacity;\n\n      this._out(\"/\" + oname + \" gs \");\n    }\n\n    this._out(\"/\" + sname + \" sh\", NL);\n\n    this.restore();\n  },\n  setDashPattern: function (dashArray, dashPhase) {\n    this._out(dashArray, \" \", dashPhase, \" d\", NL);\n  },\n  setLineWidth: function (width) {\n    this._out(width, \" w\", NL);\n  },\n  setLineCap: function (lineCap) {\n    this._out(lineCap, \" J\", NL);\n  },\n  setLineJoin: function (lineJoin) {\n    this._out(lineJoin, \" j\", NL);\n  },\n  setMitterLimit: function (mitterLimit) {\n    this._out(mitterLimit, \" M\", NL);\n  },\n  save: function () {\n    this._contextStack.push(this._context());\n\n    this._out(\"q\", NL);\n  },\n  restore: function () {\n    this._out(\"Q\", NL);\n\n    this._context(this._contextStack.pop());\n  },\n  // paths\n  moveTo: function (x, y) {\n    this._out(x, \" \", y, \" m\", NL);\n  },\n  lineTo: function (x, y) {\n    this._out(x, \" \", y, \" l\", NL);\n  },\n  bezier: function (x1, y1, x2, y2, x3, y3) {\n    this._out(x1, \" \", y1, \" \", x2, \" \", y2, \" \", x3, \" \", y3, \" c\", NL);\n  },\n  bezier1: function (x1, y1, x3, y3) {\n    this._out(x1, \" \", y1, \" \", x3, \" \", y3, \" y\", NL);\n  },\n  bezier2: function (x2, y2, x3, y3) {\n    this._out(x2, \" \", y2, \" \", x3, \" \", y3, \" v\", NL);\n  },\n  close: function () {\n    this._out(\"h\", NL);\n  },\n  rect: function (x, y, w, h) {\n    this._out(x, \" \", y, \" \", w, \" \", h, \" re\", NL);\n  },\n  ellipse: function (x, y, rx, ry) {\n    function _X(v) {\n      return x + v;\n    }\n\n    function _Y(v) {\n      return y + v;\n    } // how to get to the \"magic number\" is explained here:\n    // http://www.whizkidtech.redprince.net/bezier/circle/kappa/\n\n\n    var k = 0.5522847498307936;\n    this.moveTo(_X(0), _Y(ry));\n    this.bezier(_X(rx * k), _Y(ry), _X(rx), _Y(ry * k), _X(rx), _Y(0));\n    this.bezier(_X(rx), _Y(-ry * k), _X(rx * k), _Y(-ry), _X(0), _Y(-ry));\n    this.bezier(_X(-rx * k), _Y(-ry), _X(-rx), _Y(-ry * k), _X(-rx), _Y(0));\n    this.bezier(_X(-rx), _Y(ry * k), _X(-rx * k), _Y(ry), _X(0), _Y(ry));\n  },\n  circle: function (x, y, r) {\n    this.ellipse(x, y, r, r);\n  },\n  stroke: function () {\n    this._out(\"S\", NL);\n  },\n  nop: function () {\n    this._out(\"n\", NL);\n  },\n  clip: function () {\n    this._out(\"W n\", NL);\n  },\n  clipStroke: function () {\n    this._out(\"W S\", NL);\n  },\n  closeStroke: function () {\n    this._out(\"s\", NL);\n  },\n  fill: function () {\n    this._out(\"f\", NL);\n  },\n  fillStroke: function () {\n    this._out(\"B\", NL);\n  },\n  drawImage: function (url) {\n    var img = this._pdf.getImage(url);\n\n    if (img) {\n      // the result can be null for a cross-domain image\n      this._xResources[img._resourceName] = img;\n\n      this._out(img._resourceName, \" Do\", NL);\n    }\n  },\n  comment: function (txt) {\n    var self = this;\n    txt.split(/\\r?\\n/g).forEach(function (line) {\n      self._out(\"% \", line, NL);\n    });\n  },\n  // internal\n  _context: function (val) {\n    if (val != null) {\n      this._opacity = val.opacity;\n      this._matrix = val.matrix;\n    } else {\n      return {\n        opacity: this._opacity,\n        matrix: this._matrix\n      };\n    }\n  },\n  _toPage: function (p) {\n    var m = this._matrix;\n    var a = m[0],\n        b = m[1],\n        c = m[2],\n        d = m[3],\n        e = m[4],\n        f = m[5];\n    return {\n      x: a * p.x + c * p.y + e,\n      y: b * p.x + d * p.y + f\n    };\n  }\n}, PDFDictionary);\n\nfunction unquote(str) {\n  return str.replace(/^\\s*(['\"])(.*)\\1\\s*$/, \"$2\");\n}\n\nfunction parseFontDef(fontdef) {\n  // XXX: this is very crude for now and buggy.  Proper parsing is quite involved.\n  var rx = /^\\s*((normal|italic)\\s+)?((normal|small-caps)\\s+)?((normal|bold|\\d+)\\s+)?(([0-9.]+)(px|pt))(\\/(([0-9.]+)(px|pt)|normal))?\\s+(.*?)\\s*$/i;\n  var m = rx.exec(fontdef);\n\n  if (!m) {\n    return {\n      fontSize: 12,\n      fontFamily: \"sans-serif\"\n    };\n  }\n\n  var fontSize = m[8] ? parseInt(m[8], 10) : 12;\n  return {\n    italic: m[2] && m[2].toLowerCase() == \"italic\",\n    variant: m[4],\n    bold: m[6] && /bold|700/i.test(m[6]),\n    fontSize: fontSize,\n    lineHeight: m[12] ? m[12] == \"normal\" ? fontSize : parseInt(m[12], 10) : null,\n    fontFamily: m[14].split(/\\s*,\\s*/g).map(unquote)\n  };\n}\n\nfunction getFontURL(style) {\n  function mkFamily(name) {\n    if (style.bold) {\n      name += \"|bold\";\n    }\n\n    if (style.italic) {\n      name += \"|italic\";\n    }\n\n    return name.toLowerCase();\n  }\n\n  var fontFamily = style.fontFamily;\n  var name, url;\n\n  if (fontFamily instanceof Array) {\n    for (var i = 0; i < fontFamily.length; ++i) {\n      name = mkFamily(fontFamily[i]);\n      url = FONT_MAPPINGS[name];\n\n      if (url) {\n        break;\n      }\n    }\n  } else {\n    url = FONT_MAPPINGS[fontFamily.toLowerCase()];\n  }\n\n  while (typeof url == \"function\") {\n    url = url();\n  }\n\n  if (!url) {\n    url = \"Times-Roman\";\n  }\n\n  return url;\n}\n\nvar FONT_MAPPINGS = {\n  \"serif\": \"Times-Roman\",\n  \"serif|bold\": \"Times-Bold\",\n  \"serif|italic\": \"Times-Italic\",\n  \"serif|bold|italic\": \"Times-BoldItalic\",\n  \"sans-serif\": \"Helvetica\",\n  \"sans-serif|bold\": \"Helvetica-Bold\",\n  \"sans-serif|italic\": \"Helvetica-Oblique\",\n  \"sans-serif|bold|italic\": \"Helvetica-BoldOblique\",\n  \"monospace\": \"Courier\",\n  \"monospace|bold\": \"Courier-Bold\",\n  \"monospace|italic\": \"Courier-Oblique\",\n  \"monospace|bold|italic\": \"Courier-BoldOblique\",\n  \"zapfdingbats\": \"ZapfDingbats\",\n  \"zapfdingbats|bold\": \"ZapfDingbats\",\n  \"zapfdingbats|italic\": \"ZapfDingbats\",\n  \"zapfdingbats|bold|italic\": \"ZapfDingbats\"\n};\n\nfunction fontAlias(alias, name) {\n  alias = alias.toLowerCase();\n\n  FONT_MAPPINGS[alias] = function () {\n    return FONT_MAPPINGS[name];\n  };\n\n  FONT_MAPPINGS[alias + \"|bold\"] = function () {\n    return FONT_MAPPINGS[name + \"|bold\"];\n  };\n\n  FONT_MAPPINGS[alias + \"|italic\"] = function () {\n    return FONT_MAPPINGS[name + \"|italic\"];\n  };\n\n  FONT_MAPPINGS[alias + \"|bold|italic\"] = function () {\n    return FONT_MAPPINGS[name + \"|bold|italic\"];\n  };\n} // Let's define some common names to an appropriate replacement.\n// These are overridable via pdf.defineFont, should the user want to\n// include the proper versions.\n\n\nfontAlias(\"Times New Roman\", \"serif\");\nfontAlias(\"Courier New\", \"monospace\");\nfontAlias(\"Arial\", \"sans-serif\");\nfontAlias(\"Helvetica\", \"sans-serif\");\nfontAlias(\"Verdana\", \"sans-serif\");\nfontAlias(\"Tahoma\", \"sans-serif\");\nfontAlias(\"Georgia\", \"sans-serif\");\nfontAlias(\"Monaco\", \"monospace\");\nfontAlias(\"Andale Mono\", \"monospace\");\n\nfunction defineFont(name, url) {\n  if (arguments.length == 1) {\n    for (var i in name) {\n      if (hasOwnProperty(name, i)) {\n        defineFont(i, name[i]);\n      }\n    }\n  } else {\n    name = name.toLowerCase();\n    FONT_MAPPINGS[name] = url; // special handling for DejaVu fonts: if they get defined,\n    // let them also replace the default families, for good\n    // Unicode support out of the box.\n\n    switch (name) {\n      case \"dejavu sans\":\n        FONT_MAPPINGS[\"sans-serif\"] = url;\n        break;\n\n      case \"dejavu sans|bold\":\n        FONT_MAPPINGS[\"sans-serif|bold\"] = url;\n        break;\n\n      case \"dejavu sans|italic\":\n        FONT_MAPPINGS[\"sans-serif|italic\"] = url;\n        break;\n\n      case \"dejavu sans|bold|italic\":\n        FONT_MAPPINGS[\"sans-serif|bold|italic\"] = url;\n        break;\n\n      case \"dejavu serif\":\n        FONT_MAPPINGS[\"serif\"] = url;\n        break;\n\n      case \"dejavu serif|bold\":\n        FONT_MAPPINGS[\"serif|bold\"] = url;\n        break;\n\n      case \"dejavu serif|italic\":\n        FONT_MAPPINGS[\"serif|italic\"] = url;\n        break;\n\n      case \"dejavu serif|bold|italic\":\n        FONT_MAPPINGS[\"serif|bold|italic\"] = url;\n        break;\n\n      case \"dejavu mono\":\n        FONT_MAPPINGS[\"monospace\"] = url;\n        break;\n\n      case \"dejavu mono|bold\":\n        FONT_MAPPINGS[\"monospace|bold\"] = url;\n        break;\n\n      case \"dejavu mono|italic\":\n        FONT_MAPPINGS[\"monospace|italic\"] = url;\n        break;\n\n      case \"dejavu mono|bold|italic\":\n        FONT_MAPPINGS[\"monospace|bold|italic\"] = url;\n        break;\n    }\n  }\n}\n\nfunction mmul(a, b) {\n  var a1 = a[0],\n      b1 = a[1],\n      c1 = a[2],\n      d1 = a[3],\n      e1 = a[4],\n      f1 = a[5];\n  var a2 = b[0],\n      b2 = b[1],\n      c2 = b[2],\n      d2 = b[3],\n      e2 = b[4],\n      f2 = b[5];\n  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];\n}\n\nfunction isIdentityMatrix(m) {\n  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;\n}\n\nvar TEXT_RENDERING_MODE = {\n  fill: 0,\n  stroke: 1,\n  fillAndStroke: 2,\n  invisible: 3,\n  fillAndClip: 4,\n  strokeAndClip: 5,\n  fillStrokeClip: 6,\n  clip: 7\n};\nexport { PDFDocument as Document, BinaryStream, defineFont, parseFontDef, getFontURL, loadFonts, loadImages, getPaperOptions, clearImageCache, TEXT_RENDERING_MODE };","map":null,"metadata":{},"sourceType":"module"}