{"ast":null,"code":"import Point from '../geometry/point';\nimport { last } from '../util';\nvar ShapeMap = {\n  l: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 2) {\n      var point = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        point.translateWith(position);\n      }\n\n      path.lineTo(point.x, point.y);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  c: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 6) {\n      var controlOut = new Point(parameters[i], parameters[i + 1]);\n      var controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n      var point = new Point(parameters[i + 4], parameters[i + 5]);\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        controlOut.translateWith(position);\n        point.translateWith(position);\n      }\n\n      path.curveTo(controlOut, controlIn, point);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  v: function (path, options) {\n    var value = options.isRelative ? 0 : options.position.x;\n    toLineParamaters(options.parameters, true, value);\n    this.l(path, options);\n  },\n  h: function (path, options) {\n    var value = options.isRelative ? 0 : options.position.y;\n    toLineParamaters(options.parameters, false, value);\n    this.l(path, options);\n  },\n  a: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 7) {\n      var radiusX = parameters[i];\n      var radiusY = parameters[i + 1];\n      var rotation = parameters[i + 2];\n      var largeArc = parameters[i + 3];\n      var swipe = parameters[i + 4];\n      var endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (position.x !== endPoint.x || position.y !== endPoint.y) {\n        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n        position.x = endPoint.x;\n        position.y = endPoint.y;\n      }\n    }\n  },\n  s: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n    var previousCommand = options.previousCommand;\n    var lastControlIn;\n\n    if (previousCommand === \"s\" || previousCommand === \"c\") {\n      lastControlIn = last(last(path.paths).segments).controlIn();\n    }\n\n    for (var i = 0; i < parameters.length; i += 4) {\n      var controlIn = new Point(parameters[i], parameters[i + 1]);\n      var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n      var controlOut = void 0;\n\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      if (lastControlIn) {\n        controlOut = reflectionPoint(lastControlIn, position);\n      } else {\n        controlOut = position.clone();\n      }\n\n      lastControlIn = controlIn;\n      path.curveTo(controlOut, controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  q: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n\n    for (var i = 0; i < parameters.length; i += 4) {\n      var controlPoint = new Point(parameters[i], parameters[i + 1]);\n      var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n      if (options.isRelative) {\n        controlPoint.translateWith(position);\n        endPoint.translateWith(position);\n      }\n\n      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  t: function (path, options) {\n    var parameters = options.parameters;\n    var position = options.position;\n    var previousCommand = options.previousCommand;\n    var controlPoint;\n\n    if (previousCommand === \"q\" || previousCommand === \"t\") {\n      var lastSegment = last(last(path.paths).segments);\n      controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);\n    }\n\n    for (var i = 0; i < parameters.length; i += 2) {\n      var endPoint = new Point(parameters[i], parameters[i + 1]);\n\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n\n      if (controlPoint) {\n        controlPoint = reflectionPoint(controlPoint, position);\n      } else {\n        controlPoint = position.clone();\n      }\n\n      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n  var insertPosition = isVertical ? 0 : 1;\n\n  for (var i = 0; i < parameters.length; i += 2) {\n    parameters.splice(i + insertPosition, 0, value);\n  }\n}\n\nfunction reflectionPoint(point, center) {\n  if (point && center) {\n    return center.scaleCopy(2).translate(-point.x, -point.y);\n  }\n}\n\nvar third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n  var scaledPoint = controlPoint.clone().scale(2 / 3);\n  return {\n    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n  };\n}\n\nexport default ShapeMap;","map":null,"metadata":{},"sourceType":"module"}