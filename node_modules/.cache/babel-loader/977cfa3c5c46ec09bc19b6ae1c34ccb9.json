{"ast":null,"code":"import Class from '../class';\nimport support from '../support';\nimport namedColors from './named-colors';\nvar browser = support.browser;\n\nvar matchNamedColor = function (color) {\n  var colorNames = Object.keys(namedColors);\n  colorNames.push(\"transparent\");\n  var regexp = new RegExp(\"^(\" + colorNames.join(\"|\") + \")(\\\\W|$)\", \"i\");\n\n  matchNamedColor = function (color) {\n    return regexp.exec(color);\n  };\n\n  return regexp.exec(color);\n};\n\nvar BaseColor = function (Class) {\n  function BaseColor() {\n    Class.call(this);\n  }\n\n  if (Class) BaseColor.__proto__ = Class;\n  BaseColor.prototype = Object.create(Class && Class.prototype);\n  BaseColor.prototype.constructor = BaseColor;\n\n  BaseColor.prototype.toHSV = function toHSV() {\n    return this;\n  };\n\n  BaseColor.prototype.toRGB = function toRGB() {\n    return this;\n  };\n\n  BaseColor.prototype.toHex = function toHex() {\n    return this.toBytes().toHex();\n  };\n\n  BaseColor.prototype.toBytes = function toBytes() {\n    return this;\n  };\n\n  BaseColor.prototype.toCss = function toCss() {\n    return \"#\" + this.toHex();\n  };\n\n  BaseColor.prototype.toCssRgba = function toCssRgba() {\n    var rgb = this.toBytes();\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + parseFloat(Number(this.a).toFixed(3)) + \")\";\n  };\n\n  BaseColor.prototype.toDisplay = function toDisplay() {\n    if (browser.msie && browser.version < 9) {\n      return this.toCss(); // no RGBA support; does it support any opacity in colors?\n    }\n\n    return this.toCssRgba();\n  };\n\n  BaseColor.prototype.equals = function equals(c) {\n    return c === this || c !== null && this.toCssRgba() === parseColor(c).toCssRgba();\n  };\n\n  BaseColor.prototype.diff = function diff(other) {\n    if (other === null) {\n      return NaN;\n    }\n\n    var c1 = this.toBytes();\n    var c2 = other.toBytes();\n    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.30, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));\n  };\n\n  BaseColor.prototype.clone = function clone() {\n    var c = this.toBytes();\n\n    if (c === this) {\n      c = new Bytes(c.r, c.g, c.b, c.a);\n    }\n\n    return c;\n  };\n\n  return BaseColor;\n}(Class);\n\nvar RGB = function (BaseColor) {\n  function RGB(r, g, b, a) {\n    BaseColor.call(this);\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  if (BaseColor) RGB.__proto__ = BaseColor;\n  RGB.prototype = Object.create(BaseColor && BaseColor.prototype);\n  RGB.prototype.constructor = RGB;\n\n  RGB.prototype.toHSV = function toHSV() {\n    var ref = this;\n    var r = ref.r;\n    var g = ref.g;\n    var b = ref.b;\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var v = max;\n    var h, s;\n\n    if (delta === 0) {\n      return new HSV(0, 0, v, this.a);\n    }\n\n    if (max !== 0) {\n      s = delta / max;\n\n      if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n\n      h *= 60;\n\n      if (h < 0) {\n        h += 360;\n      }\n    } else {\n      s = 0;\n      h = -1;\n    }\n\n    return new HSV(h, s, v, this.a);\n  };\n\n  RGB.prototype.toHSL = function toHSL() {\n    var ref = this;\n    var r = ref.r;\n    var g = ref.g;\n    var b = ref.b;\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var h,\n        s,\n        l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      var d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n\n        case g:\n          h = (b - r) / d + 2;\n          break;\n\n        case b:\n          h = (r - g) / d + 4;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return new HSL(h * 60, s * 100, l * 100, this.a);\n  };\n\n  RGB.prototype.toBytes = function toBytes() {\n    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);\n  };\n\n  return RGB;\n}(BaseColor);\n\nvar Bytes = function (RGB) {\n  function Bytes(r, g, b, a) {\n    RGB.call(this, Math.round(r), Math.round(g), Math.round(b), a);\n  }\n\n  if (RGB) Bytes.__proto__ = RGB;\n  Bytes.prototype = Object.create(RGB && RGB.prototype);\n  Bytes.prototype.constructor = Bytes;\n\n  Bytes.prototype.toRGB = function toRGB() {\n    return new RGB(this.r / 255, this.g / 255, this.b / 255, this.a);\n  };\n\n  Bytes.prototype.toHSV = function toHSV() {\n    return this.toRGB().toHSV();\n  };\n\n  Bytes.prototype.toHSL = function toHSL() {\n    return this.toRGB().toHSL();\n  };\n\n  Bytes.prototype.toHex = function toHex() {\n    return hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);\n  };\n\n  Bytes.prototype.toBytes = function toBytes() {\n    return this;\n  };\n\n  return Bytes;\n}(RGB);\n\nfunction hex(n, width, pad) {\n  if (pad === void 0) pad = \"0\";\n  var result = n.toString(16);\n\n  while (width > result.length) {\n    result = pad + result;\n  }\n\n  return result;\n}\n\nvar HSV = function (BaseColor) {\n  function HSV(h, s, v, a) {\n    BaseColor.call(this);\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  if (BaseColor) HSV.__proto__ = BaseColor;\n  HSV.prototype = Object.create(BaseColor && BaseColor.prototype);\n  HSV.prototype.constructor = HSV;\n\n  HSV.prototype.toRGB = function toRGB() {\n    var ref = this;\n    var h = ref.h;\n    var s = ref.s;\n    var v = ref.v;\n    var r, g, b;\n\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      h /= 60;\n      var i = Math.floor(h);\n      var f = h - i;\n      var p = v * (1 - s);\n      var q = v * (1 - s * f);\n      var t = v * (1 - s * (1 - f));\n\n      switch (i) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n\n        default:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n\n    return new RGB(r, g, b, this.a);\n  };\n\n  HSV.prototype.toHSL = function toHSL() {\n    return this.toRGB().toHSL();\n  };\n\n  HSV.prototype.toBytes = function toBytes() {\n    return this.toRGB().toBytes();\n  };\n\n  return HSV;\n}(BaseColor);\n\nvar HSL = function (BaseColor) {\n  function HSL(h, s, l, a) {\n    BaseColor.call(this);\n    this.h = h;\n    this.s = s;\n    this.l = l;\n    this.a = a;\n  }\n\n  if (BaseColor) HSL.__proto__ = BaseColor;\n  HSL.prototype = Object.create(BaseColor && BaseColor.prototype);\n  HSL.prototype.constructor = HSL;\n\n  HSL.prototype.toRGB = function toRGB() {\n    var h = this.h / 360;\n    var s = this.s / 100;\n    var l = this.l / 100;\n    var r, g, b;\n\n    if (s === 0) {\n      r = g = b = l; // achromatic\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return new RGB(r, g, b, this.a);\n  };\n\n  HSL.prototype.toHSV = function toHSV() {\n    return this.toRGB().toHSV();\n  };\n\n  HSL.prototype.toBytes = function toBytes() {\n    return this.toRGB().toBytes();\n  };\n\n  return HSL;\n}(BaseColor);\n\nfunction hue2rgb(p, q, s) {\n  var t = s;\n\n  if (t < 0) {\n    t += 1;\n  }\n\n  if (t > 1) {\n    t -= 1;\n  }\n\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n\n  if (t < 1 / 2) {\n    return q;\n  }\n\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n\n  return p;\n}\n\nexport { RGB, Bytes, HSV, HSL };\nexport default function parseColor(value, safe) {\n  var m, ret;\n\n  if (value == null || value === \"none\") {\n    return null;\n  }\n\n  if (value instanceof BaseColor) {\n    return value;\n  }\n\n  var color = value.toLowerCase();\n\n  if (m = matchNamedColor(color)) {\n    if (m[1] === \"transparent\") {\n      color = new RGB(1, 1, 1, 0);\n    } else {\n      color = parseColor(namedColors[m[1]], safe);\n    }\n\n    color.match = [m[1]];\n    return color;\n  }\n\n  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\\b/i.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1);\n  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\\b/i.exec(color)) {\n    ret = new Bytes(parseInt(m[1] + m[1], 16), parseInt(m[2] + m[2], 16), parseInt(m[3] + m[3], 16), 1);\n  } else if (m = /^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), 1);\n  } else if (m = /^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color)) {\n    ret = new Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4]));\n  } else if (m = /^rgb\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*\\)/.exec(color)) {\n    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, 1);\n  } else if (m = /^rgba\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color)) {\n    ret = new RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, parseFloat(m[4]));\n  }\n\n  if (ret) {\n    ret.match = m;\n  } else if (!safe) {\n    throw new Error(\"Cannot parse color: \" + color);\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}