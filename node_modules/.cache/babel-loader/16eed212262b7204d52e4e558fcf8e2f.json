{"ast":null,"code":"import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { Class } from '../common';\nimport { rad } from '../util';\nvar PI_DIV_2 = Math.PI / 2;\n\nvar Circle = function (Class) {\n  function Circle(center, radius) {\n    if (center === void 0) center = new Point();\n    if (radius === void 0) radius = 0;\n    Class.call(this);\n    this.setCenter(center);\n    this.setRadius(radius);\n  }\n\n  if (Class) Circle.__proto__ = Class;\n  Circle.prototype = Object.create(Class && Class.prototype);\n  Circle.prototype.constructor = Circle;\n\n  Circle.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Circle.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n\n  Circle.prototype.equals = function equals(other) {\n    return other && other.center.equals(this.center) && other.radius === this.radius;\n  };\n\n  Circle.prototype.clone = function clone() {\n    return new Circle(this.center.clone(), this.radius);\n  };\n\n  Circle.prototype.pointAt = function pointAt(angle) {\n    return this._pointAt(rad(angle));\n  };\n\n  Circle.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n    var minPoint = Point.maxPoint();\n    var maxPoint = Point.minPoint();\n\n    for (var i = 0; i < 4; i++) {\n      var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n\n      var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n\n      var currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n\n  Circle.prototype._pointAt = function _pointAt(angle) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    return new Point(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n  };\n\n  Circle.prototype.containsPoint = function containsPoint(point) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    var inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n    return inCircle;\n  };\n\n  Circle.prototype._isOnPath = function _isOnPath(point, width) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    var pointDistance = center.distanceTo(point);\n    return radius - width <= pointDistance && pointDistance <= radius + width;\n  };\n\n  return Circle;\n}(Class);\n\ndefineAccessors(Circle.prototype, [\"radius\"]);\nObserversMixin.extend(Circle.prototype);\nexport default Circle;","map":null,"metadata":{},"sourceType":"module"}