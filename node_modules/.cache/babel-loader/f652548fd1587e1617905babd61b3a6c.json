{"ast":null,"code":"import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport { deg, rad, round } from '../util';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\n\nvar Arc = function (Class) {\n  function Arc(center, options) {\n    if (center === void 0) center = new Point();\n    if (options === void 0) options = {};\n    Class.call(this);\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n\n  if (Class) Arc.__proto__ = Class;\n  Arc.prototype = Object.create(Class && Class.prototype);\n  Arc.prototype.constructor = Arc;\n\n  Arc.prototype.clone = function clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  };\n\n  Arc.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Arc.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n\n  Arc.prototype.pointAt = function pointAt(angle) {\n    var center = this.center;\n    var radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  };\n\n  Arc.prototype.curvePoints = function curvePoints() {\n    var this$1 = this;\n    var startAngle = this.startAngle;\n    var dir = this.anticlockwise ? -1 : 1;\n    var curvePoints = [this.pointAt(startAngle)];\n\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    var subIntervalAngle = intervalAngle / subIntervalsCount;\n    var currentAngle = startAngle;\n    var transformation;\n\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n\n    for (var i = 1; i <= subIntervalsCount; i++) {\n      var nextAngle = currentAngle + dir * subIntervalAngle;\n\n      var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n\n    return curvePoints;\n  };\n\n  Arc.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n\n    var interval = this._arcInterval();\n\n    var startAngle = interval.startAngle;\n    var endAngle = interval.endAngle;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    var extremeX = deg(extremeAngles.x);\n    var extremeY = deg(extremeAngles.y);\n    var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    var currentAngleX = bboxStartAngle(extremeX, startAngle);\n    var currentAngleY = bboxStartAngle(extremeY, startAngle);\n    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    var minPoint = Point.min(currentPoint, endPoint);\n    var maxPoint = Point.max(currentPoint, endPoint);\n\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      var currentPointX = void 0;\n\n      if (currentAngleX < endAngle) {\n        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n\n      var currentPointY = void 0;\n\n      if (currentAngleY < endAngle) {\n        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n\n  Arc.prototype._arcInterval = function _arcInterval() {\n    var ref = this;\n    var startAngle = ref.startAngle;\n    var endAngle = ref.endAngle;\n    var anticlockwise = ref.anticlockwise;\n\n    if (anticlockwise) {\n      var oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  };\n\n  Arc.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {\n    var p1 = this.pointAt(startAngle);\n    var p2 = this.pointAt(endAngle);\n\n    var p1Derivative = this._derivativeAt(startAngle);\n\n    var p2Derivative = this._derivativeAt(endAngle);\n\n    var t = (rad(endAngle) - rad(startAngle)) / 3;\n    var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  };\n\n  Arc.prototype._derivativeAt = function _derivativeAt(angle) {\n    var radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  };\n\n  Arc.prototype.containsPoint = function containsPoint(point) {\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var ref = this;\n    var center = ref.center;\n    var radiusX = ref.radiusX;\n    var radiusY = ref.radiusY;\n    var distance = center.distanceTo(point);\n    var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    var containsPoint;\n\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n\n      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n\n    return containsPoint;\n  };\n\n  Arc.prototype._isOnPath = function _isOnPath(point, width) {\n    var interval = this._arcInterval();\n\n    var center = this.center;\n    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n\n    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  };\n\n  Arc.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    var arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  };\n\n  return Arc;\n}(Class);\n\ndefineAccessors(Arc.prototype, [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"]);\nObserversMixin.extend(Arc.prototype);\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  var cos = round((x - cx) / rx, 3);\n  var sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n  var x1 = parameters.x1;\n  var y1 = parameters.y1;\n  var x2 = parameters.x2;\n  var y2 = parameters.y2;\n  var rx = parameters.rx;\n  var ry = parameters.ry;\n  var largeArc = parameters.largeArc;\n  var swipe = parameters.swipe;\n  var rotation = parameters.rotation;\n  if (rotation === void 0) rotation = 0;\n  var radians = rad(rotation);\n  var cosine = Math.cos(radians);\n  var sine = Math.sin(radians);\n  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  var sign = largeArc !== swipe ? 1 : -1;\n  var xt2 = Math.pow(xT, 2);\n  var yt2 = Math.pow(yT, 2);\n  var rx2 = Math.pow(rx, 2);\n  var ry2 = Math.pow(ry, 2);\n  var delta = xt2 / rx2 + yt2 / ry2;\n\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n\n  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n\n  var cxT = constT * (rx * yT) / ry;\n  var cyT = -constT * (ry * xT) / rx;\n  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  var uX = (xT - cxT) / rx;\n  var uY = (yT - cyT) / ry;\n  var vX = -(xT + cxT) / rx;\n  var vY = -(yT + cyT) / ry;\n  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n\n  var endAngle = startAngle + angle;\n  var signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\n\nfunction bboxStartAngle(angle, start) {\n  var startAngle = angle;\n\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n\n  return startAngle;\n}\n\nexport default Arc;","map":null,"metadata":{},"sourceType":"module"}